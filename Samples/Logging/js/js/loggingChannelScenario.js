//// Copyright (c) Microsoft Corporation. All rights reserved

(function () {

    var d = Windows.Foundation.Diagnostics;

    /// <summary>
    /// Demonstrate usage of LoggingChannel and LoggingActivity.
    /// </summary>
    var LoggingChannelScenario = WinJS.Class.define(
        function () {
        },
        {
            /// <summary>
            /// Construct a LoggingChannel with the Windows 8.1 constructor, then
            /// use the LoggingChannel for the scenario.
            /// </summary>
            logWithWin81Constructor: function () {
                /*
                You can collect the events generated by this method with xperf or another
                ETL controller tool. To collect these events in an ETL file:
    
                xperf -start MySession -f MyFile.etl -on 4bd2826e-54a1-4ba9-bf63-92b73ea1ac4a
                (run the sample and click the "Windows 8.1 behavior" button)
                xperf -stop MySession
    
                After collecting the ETL file, you can decode the trace using xperf, wpa,
                or tracerpt. For example, to decode MyFile.etl with tracerpt:
    
                tracerpt MyFile.etl
                (generates dumpfile.xml)
    
                Note that decoding TraceLogging events requires Windows 10. Earlier versions
                of Windows can only reliably decode the simple (manifest-based) events.
                */

                /*
                If a LoggingChannel is created using the 1-parameter constructor, it
                will use Windows 8.1 semantics:
    
                - The channel's ETW Id is always "4bd2826e-54a1-4ba9-bf63-92b73ea1ac4a".
                - The channel's ETW Name is is always
                  "Microsoft-Windows-Diagnostics-LoggingChannel".
                - A LoggingChannelName field containing the Channel Name is automatically
                  added to each event.
                - Simple events will be written using manifested-event encoding.
                
                Note that complex events can be written even when using Windows 8.1 mode.
                Complex events always use TraceLogging encoding.
    
                The 1-parameter constructor is marked as obsolete to ensure that
                developers are aware of the changes in semantics. The Windows 10 semantics
                are useful because they enable use of the ETW Provider Id for event
                filtering.
                */

                /*
                If a LoggingChannel is used as a local or member variable, it should
                be closed (disposed) when no longer needed.
                */

                {
                    // The 1-parameter constructor creates a channel with Windows 8.1 semantics.
                    var channel = new d.LoggingChannel("SampleProvider");

                    // The Id for a Windows 8.1-mode channel is always the same.
                    // channel.Id == 4bd2826e-54a1-4ba9-bf63-92b73ea1ac4a

                    this.demonstrateLogging(channel);
                    channel.close();
                }
            },

            /// <summary>
            /// Construct a LoggingChannel with the Windows 10 constructor, then
            /// use the LoggingChannel for the scenario. Also show the use cases
            /// for the two Windows 10 constructors.
            /// </summary>
            logWithWin10Constructor: function () {
                /*
                You can collect the events generated by this method with xperf or another
                ETL controller tool. To collect these events in an ETL file:
    
                xperf -start MySession -f MyFile.etl -on eff1e128-4903-5093-096a-bdc29b38456f
                (run the sample and click the "Windows 10 behavior" button)
                xperf -stop MySession
    
                After collecting the ETL file, you can decode the trace using xperf, wpa,
                or tracerpt. For example, to decode MyFile.etl with tracerpt:
    
                tracerpt MyFile.etl
                (generates dumpfile.xml)
    
                Note that decoding TraceLogging events requires Windows 10. Earlier versions
                of Windows can only reliably decode the simple (manifest-based) events.
                */

                /*
                If a LoggingChannel is created using the 2-parameter or 3-parameter
                constructors, it will use Windows 10 semantics:
    
                - The channel's ETW Provider Id can be controlled by the developer.
                - The channel's ETW Name is the same as the Channel Name.
                - The LoggingChannelName field is not automatically added to each event.
                - All events will be written using TraceLogging encoding.
                
                The 1-parameter constructor is marked as obsolete to ensure that
                developers are aware of the changes in semantics. The Windows 10 semantics
                are useful because they enable use of the ETW Provider Id for event
                filtering.
    
                The 2-parameter constructor accepts a channel name and channel options.
                If the options parameter is null, default options are used. At present,
                the only available option is the channel's group GUID. When using the
                2-parameter constructor, the channel's ETW Id is determined by hashing
                the channel name. (The hashing algorithm is the same as the one used by
                the .NET EventSource class.)
    
                The 3-parameter constructor accepts channel name, channel options, and
                the ETW Id. This constructor should be used when you need your channel
                to use a specific ETW Id and cannot use the default hashed channel name
                as your ETW Id.
                */

                /*
                If a LoggingChannel is used as a local or member variable, it should
                be closed (disposed) when no longer needed.
                */

                {
                    // The 2-parameter constructor creates a channel with Windows 10 semantics.
                    var channel = new d.LoggingChannel(
                        "SampleProvider",
                        null); // null means use default options.

                    // The Id is generated by hashing the string "SampleProvider".
                    // channel.Id == eff1e128-4903-5093-096a-bdc29b38456f

                    this.demonstrateLogging(channel);

                    channel.close();
                }

                /*
                Demonstrate other (less-common) constructor scenarios:
                */

                {
                    // This creates a channel with Windows 10 semantics and declared
                    // membership in a provider group.
                    var channel = new d.LoggingChannel(
                        "SampleProvider",
                        new d.LoggingChannelOptions("2e0582f3-d1b6-516a-9de3-9fd79ef952f8")); // Join a provider group

                    // The Id is generated by hashing the string "SampleProvider".
                    // channel.Id == eff1e128-4903-5093-096a-bdc29b38456f
                }

                {
                    // This creates a channel with Windows 10 semantics and a specific
                    // provider Id.
                    var channel = new d.LoggingChannel(
                        "SampleProvider",
                        null,
                        "2e0582f3-d1b6-516a-9de3-9fd79ef952f8");
                    // channel.Id == 2e0582f3-d1b6-516a-9de3-9fd79ef952f8
                }
            },

            /// <summary>
            /// This method demonstrates the LoggingChannel and LoggingActivity APIs.
            /// </summary>
            /// <param name="channel">
            /// The channel to use for the demonstration. This channel may have been
            /// constructed using a Windows 8.1 constructor or a Windows 10 constructor.
            /// The same APIs are supported in both cases, but the ETL events will be
            /// formatted a bit differently depending on how the channel was constructed.
            /// </param>
            demonstrateLogging: function (channel) {
                // Whenever any ETW session changes the way it is listening to this
                // channel, the LoggingEnable event is fired. For example, this might
                // be called when a session begins listening, changes the level at
                // which it is listening, or stops listening.
                channel.addEventListener("loggingenabled", this.onLoggingEnabled);

                // Log simple string events
                channel.logMessage("Simple message"); // default level is Verbose
                channel.logMessage("Simple error", d.LoggingLevel.error);

                // Log simple string + integer events.
                channel.logValuePair("Simple message", 123); // default level is Verbose
                channel.logValuePair("Simple error", 456, d.LoggingLevel.error);

                // The channel.Name property returns the name that was used when the
                // channel was constructed. When running in Windows 10 mode, the name
                // is already set as the provider name, so no LoggingChannelName is
                // automatically added to the event.
                channel.logMessage(channel.name);

                // The channel.Id property is new to Windows 10.
                channel.logMessage(channel.id.toString());

                // If you want to avoid the overhead of collecting data when nobody is
                // listening to your channel, check the Enabled property before logging.
                if (channel.enabled)
                {
                    channel.logMessage(this.collectExpensiveData());
                }

                // The IsEnabled() method is exactly the same as the Enabled property,
                // except that it is a new Windows 10 API.
                if (channel.isEnabled())
                {
                    channel.logMessage(this.collectExpensiveData());
                }

                // If you want to only collect data if somebody is listening at a specific
                // level, you need to check both Enabled and Level. Note that the value of
                // the Level is unspecified when Enabled is false.
                if (channel.enabled && channel.level <= d.LoggingLevel.warning)
                {
                    channel.logMessage(this.collectExpensiveData(), d.LoggingLevel.warning);
                }

                // The IsEnabled(LoggingLevel) method is a bit nicer than checking both
                // Enabled and Level, but it is only available on Windows 10 or later.
                if (channel.isEnabled(d.LoggingLevel.warning))
                {
                    channel.logMessage(this.collectExpensiveData(), d.LoggingLevel.warning);
                }

                // You can also use IsEnabled to check for keywords.
                if (channel.isEnabled(d.LoggingLevel.information, 0x10))
                {
                    channel.logMessage(this.collectExpensiveData(), d.LoggingLevel.information);
                }

                // Use LoggingFields with the LogEvent method to write complex events.
                var fields = new d.LoggingFields();
                fields.addDouble("pi", 3.14159);
                channel.logEvent(
                    "ComplexEvent",
                    fields,
                    d.LoggingLevel.verbose,
                    new d.LoggingOptions(0x10)); // Keywords = 0x10

                // You can add any number of name-value pairs to a fields object, though
                // you may encounter ETW limitations if you add too many. For example,
                // ETW is limited to a maximum event size of 64KB, and the current
                // TraceLogging decoder can handle no more than 128 fields.

                // Performance optimization: You can reuse a LoggingFields object to
                // avoid unnecessary allocations. Don't forget to call Clear()
                // between uses, and don't try to share a LoggingFields object between
                // threads.
                fields.clear();
                fields.addDateTime("Date", new Date());
                channel.logEvent("Now", fields);

                fields.clear();

                // You can add a formatting hint to affect the way a value is decoded.
                // Not all combinations are useful, and the hint may be ignored.
                // For example, you can encode an MBCS string by writing a byte array
                // with a String hint.
                fields.addUInt8Array(
                    "AnsiString",
                    [ 65, 66, 67, 49, 50, 51 ], // "ABC123"
                    d.LoggingFieldFormat.string);

                // You can add "tag" bits to a field. These are user-defined bits that
                // can be used to communicate with an event processing tool. For example,
                // you might define a tag bit to indicate that a field contains private
                // data that should not be displayed on-screen.
                fields.addString("Password", "12345", d.LoggingFieldFormat.default, 0x10);

                // You can add a "structure" to an event. A structure is a name for a
                // group of fields. Structures can nest. Call BeginStruct to add a level
                // of nesting, and call EndStruct after the last field of the structure.
                fields.beginStruct("Nested");
                    fields.addInt16("Nested-1", 1);
                    fields.addInt16("Nested-2", 2);
                    fields.beginStruct("Nested-Nested");
                        fields.addInt16("Nested-Nested-3", 3);
                    fields.endStruct();
                    fields.addInt16("Nested-4", 4);
                fields.endStruct();

                // Advanced scenarios: you can use a LoggingOptions object to control
                // detailed event settings such as keywords, opcodes, and activity Ids.
                // These have their normal ETW semantics. You can also set event tags,
                // which are bit values that can be used to communicate with the event
                // processor.
                var options = new d.LoggingOptions();
                options.keywords = 0x123;
                options.tags = 0x10;
                channel.logEvent(
                    "VeryComplexEvent",
                    fields,
                    d.LoggingLevel.information,
                    options);

                // Windows 10 introduces the ILoggingTarget interface. LoggingChannel
                // implements this interface. This interface allows components to accept
                // a logger as an parameter.
                this.doSomething(channel);

                /*
                If a LoggingActivity is created using a LoggingActivity constructor,
                it will use Windows 8.1 semantics:

                - If an activity is destroyed (garbage-collected) without being closed
                  and the associated LoggingChannel is still open, the activity will
                  write a default Stop event.
                - The default Stop event (written by the destructor or by the Close()
                  method) is encoded as a "simple" event.

                The 8.1 semantics are deprecated because the automatic generation of
                a Stop event at garbage-collection can be misleading. The Stop event
                is intended to mark the a precise point at which an activity is
                completed, while the garbage-collection of an abandoned activity is
                inherently imprecise and unpredictable.

                If a LoggingActivity is created using a StartActivity method, it will
                use Windows 10 semantics:

                - If an activity is destroyed (garbage-collected) without being closed,
                  there will be no Stop event for the activity.
                - The default Stop event (written by the Close() method) is encoded as
                  a TraceLogging event with name "ActivityClosed".
                */

                {
                    // This activity is created with Windows 8.1 semantics.
                    var a1 = new d.LoggingActivity("Activity1", channel);

                    // The activity Start event is written by the LoggingActivity constructor.
                    // You would do your activity's work here.
                    // The activity Stop event is written when the activity is closed (disposed).

                    // The Windows 10 LoggingActivity adds new methods for writing events
                    // that are marked as associated with the activity.
                    a1.logEvent("Activity event");

                    // LoggingActivity also implements the ILoggingTarget interface, so you can
                    // use either a channel or an activity as a logging target.
                    this.doSomething(a1);

                    {
                        // The Windows 10 LoggingActivity adds new methods for creating nested activities.
                        // Note that nested activities are always created with Windows 10 semantics,
                        // even when nested under an activity that is using Windows 8.1 semantics.
                        var a2 = a1.startActivity("Activity2");

                        // Nested task occurs here.

                        // The Windows 10 LoggingActivity allows you to customize the Stop event.
                        a2.stopActivity("Activity 2 stop");
                    }

                    // Because a1 is using Windows 8.1 semantics, if we did not call close(),
                    // it would attempt to write a Stop event when it is garbage collected.
                    // Writing Stop events during garbage collection is not useful, so be sure
                    // to properly stop, close, or dispose activities.
                    a1.close();
                }

                {
                    // The Windows 10 StartActivity method creates a new activity, optionally with
                    // specified fields and characteristics.
                    // This activity is created with Windows 10 semantics.
                    var a3 = channel.startActivity("Activity3");

                    // Because a3 is using Windows 10 semantics, if we did not call close(),
                    // there would be no Stop event (not even when the activity is garbage
                    // collected). To get a Stop event, be sure to stop, close, or dispose the
                    // activity.
                    a3.close();
                }
            },

            collectExpensiveData: function () {
                return "ExpensiveData";
            },

            doSomething: function (logger) {
                logger.logEvent("Did something");
            },

            onLoggingEnabled: function (sender, args) {
                // Here, you could note a change in the level or keywords.
            }
        },
        {
            // LoggingChannelScenario static members
        });

    WinJS.Class.mix(LoggingChannelScenario, WinJS.Utilities.eventMixin);

    // Export public methods & controls
    WinJS.Namespace.define("LoggingChannelScenario", {
        LoggingChannelScenario: LoggingChannelScenario
    });
})();
